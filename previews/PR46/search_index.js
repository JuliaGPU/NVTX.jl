var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = NVTX","category":"page"},{"location":"api/#Macros","page":"API","title":"Macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following macros provide the most convenient usage of this package","category":"page"},{"location":"api/","page":"API","title":"API","text":"@mark\n@range\n@annotate\n@category","category":"page"},{"location":"api/#NVTX.@mark","page":"API","title":"NVTX.@mark","text":"NVTX.@mark [message] [domain=...] [color=...] [category=...] [payload=...]\n\nInstruments an instantaneous event.\n\nmessage is a string. Default is to use \"file:lineno\"`. String interpolation is supported, but may incur additional overhead.\ndomain is a Domain. Default is to use the default domain of the current module.\ncolor is either a Colorant from the Colors.jl package, or an UInt32 containing an ARGB32 value. Default is to generate one based on the hash of the message.\ncategory: an integer describing the category of the event. Default is 0.\npayload: an optional integer (Int32, UInt32, Int64, UInt64) or floating point (Float32, Float64) value to attach to the event.\n\nExample\n\nfor i = 1:10\n    NVTX.@mark \"iterate\" payload=i\n    do_work()\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#NVTX.@range","page":"API","title":"NVTX.@range","text":"NVTX.@range [message] [domain=...] [color=...] [category=...] [payload=...] expr\n\nInstruments a range over the expr.\n\nThe default message is the expression, with file and line number. See @mark for the other arguments.\n\nExample\n\nfor i = 1:10\n    NVTX.@range \"iterate\" payload=i begin\n        do_work()\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#NVTX.@annotate","page":"API","title":"NVTX.@annotate","text":"NVTX.@annotate [message] [domain=...] [color=...] [category=...] [payload=...] function ... end\n\nInstruments a range a function definition, so that each invocation of the method will be marked with a range. Equivalent to using @range within the body of the function.\n\nThe default message is the function signature with file and line number.. See @mark for the other arguments. Function arguments can be used as range arguments.\n\nExample\n\nNVTX.@annotate payload=x function foo(x)\n    # function body\nend\n# is equivalent to\nfunction foo(x)\n    NVTX.@range payload=x begin\n        # function body\n    end\nend\n\nfoo(1)\nfoo(2)\n\n\n\n\n\n","category":"macro"},{"location":"api/#NVTX.@category","page":"API","title":"NVTX.@category","text":"NVTX.@category value name\n\nAnnotate an NVTX category value with name in the modules default domain. For convenience, this returns the evaluated value\n\nconst category_3 = @category 3 \"category 3\"\n\nA category should only be defined once for a particular value within a given domain.\n\nSee also name_category\n\n\n\n\n\n","category":"macro"},{"location":"api/#Julia-interactions","page":"API","title":"Julia interactions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"enable_gc_hooks()\nenable_inference_hook\nname_threads_julia()","category":"page"},{"location":"api/#NVTX.enable_gc_hooks-Tuple{}","page":"API","title":"NVTX.enable_gc_hooks","text":"NVTX.enable_gc_hooks(;gc=true, alloc=false, free=false)\n\nAdd NVTX hooks for the Julia garbage collector:\n\ngc: instrument GC invocations as ranges,\nalloc: instrument calls to alloc as marks (payload will contain allocation size), and\nfree: instrument calls to free as marks.\n\nIf the JULIA_NVTX_CALLBACKS environment variable is set, this will be automatically called at module initialization. JULIA_NVTX_CALLBACKS should be either a comma (,) or bar (|) separated list of callbacks to enable. For example, setting it to gc|alloc|free will enable all hooks. The  --env-var argument can be helpful for setting this variable, e.g.\n\nnsys profile --env-var=JULIA_NVTX_CALLBACKS=gc|alloc|free julia --project script.jl\n\n\n\n\n\n","category":"method"},{"location":"api/#NVTX.enable_inference_hook","page":"API","title":"NVTX.enable_inference_hook","text":"NVTX.enable_inference_hook(active::Bool=true)\n\nAdd hooks for method inference. Can also be activated by adding inference to the JULIA_NVTX_CALLBACKS environment variable.\n\n\n\n\n\n","category":"function"},{"location":"api/#NVTX.name_threads_julia-Tuple{}","page":"API","title":"NVTX.name_threads_julia","text":"name_threads_julia([namefn])\n\nName the threads owned by the Julia process using namefn(). The default is namefn() = \"julia thread $(Threads.threadid())\".\n\nThis function is called at module initialization if the profiler is active, so should not generally need to be called manually unless a custom name is required.\n\n\n\n\n\n","category":"method"},{"location":"api/#Low-level-API","page":"API","title":"Low-level API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These closely map to the C API","category":"page"},{"location":"api/","page":"API","title":"API","text":"isactive\ninitialize\nactivate\nDomain\nStringHandle\nmark\nrange_start\nrange_end\nrange_push\nrange_pop\nname_category\ngettid\nname_os_thread","category":"page"},{"location":"api/#NVTX.isactive","page":"API","title":"NVTX.isactive","text":"NVTX.isactive()\n\nDetermine if Nsight Systems profiling is currently active.\n\n\n\n\n\n","category":"function"},{"location":"api/#NVTX.initialize","page":"API","title":"NVTX.initialize","text":"initialize()\n\nForce NVTX library to initialize. The first call to any NVTX API function will automatically initialize the entire API. This can make the first call much slower than subsequent calls.\n\n\n\n\n\n","category":"function"},{"location":"api/#NVTX.activate","page":"API","title":"NVTX.activate","text":"NVTX.activate()\n\nActivate the NVTX APIs. This is called automatically when importing NVTX.jl while running under Nsight profilers. It can also be called manually to enable NVTX when running under a different profiler that is compatible with NVTX. Note that in such cases, you may have to manually set the NVTX_INJECTION64_PATH environment variable and have it point to a library that can handle the NVTX APIs.\n\n\n\n\n\n","category":"function"},{"location":"api/#NVTX.Domain","page":"API","title":"NVTX.Domain","text":"Domain(name::AbstractString)\n\nConstruct a new NVTX domain with name.\n\nSee NVTX Domains.\n\n\n\n\n\nDomain(::Module)\n\nGet the default domain for a module. If no domain has been defined for the module, a new one is created.\n\n\n\n\n\n","category":"type"},{"location":"api/#NVTX.StringHandle","page":"API","title":"NVTX.StringHandle","text":"StringHandle(domain::NVTX.Domain, string::AbstractString)\n\nRegister string with domain, returning a StringHandle object.\n\nRegistered strings are intended to increase performance by lowering instrumentation overhead.\n\n\n\n\n\n","category":"type"},{"location":"api/#NVTX.mark","page":"API","title":"NVTX.mark","text":"NVTX.mark([domain::Domain]; message, color, payload, category)\n\nMarks an instantaneous event in the application.\n\nThe domain positional argument allows specifying a custom Domain, otherise the default domain is used.\n\nOptional keyword arguments:\n\nmessage: a text string, or StringHandle object.\ncolor: a Colorant from the Colors.jl package, or an integer containing an ARGB32 value.\npayload: a value of one of the followin types: UInt64, Int64, UInt32, Int32, Float64, Float32.\ncategory: a positive integer. See name_category.\n\n\n\n\n\n","category":"function"},{"location":"api/#NVTX.range_start","page":"API","title":"NVTX.range_start","text":"NVTX.range_start([domain::Domain]; message, color, payload, category)\n\nStarts a process range.\n\nReturns a RangeId value, which should be passed to range_end.\n\nSee mark for the keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#NVTX.range_end","page":"API","title":"NVTX.range_end","text":"NVTX.range_end(range::RangeId)\n\nEnds a process range started with range_start.\n\n\n\n\n\n","category":"function"},{"location":"api/#NVTX.range_push","page":"API","title":"NVTX.range_push","text":"range_push([domain]; message, color, payload, category)\n\nStarts a nested thread range. Returns the 0-based level of range being started (the level is per-domain).\n\nMust be completed with range_pop with the same domain argument.\n\nSee mark for the keyword arguments.\n\nwarning: Warning\nBoth range_push and range_pop must be called from the same thread: this is difficult to guarantee in Julia as tasks can be migrated between threads when they are re-scheduled, so we encourage using range_start/range_end instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#NVTX.range_pop","page":"API","title":"NVTX.range_pop","text":"range_pop([domain::Domain])\n\nEnds a nested thread range created by range_push on domain.\n\nReturns the 0-based level of the range being ended.\n\n\n\n\n\n","category":"function"},{"location":"api/#NVTX.name_category","page":"API","title":"NVTX.name_category","text":"name_category([domain::Domain,] category::Integer, name::AbstractString)\n\nAnnotate an NVTX category with name. If a Domain argument is provided, then annotation only applies within that domain.\n\nSee also @category\n\n\n\n\n\n","category":"function"},{"location":"api/#NVTX.gettid","page":"API","title":"NVTX.gettid","text":"gettid()\n\nGet the system thread ID of the current Julia thread. This is compatible with name_os_thread.\n\n\n\n\n\n","category":"function"},{"location":"api/#NVTX.name_os_thread","page":"API","title":"NVTX.name_os_thread","text":"name_os_thread(threadid::Integer, name::AbstractString)\n\nAttach a name to an operating system thread. threadid is the OS thread ID, returned by gettid.\n\n\n\n\n\n","category":"function"},{"location":"#NVTX.jl","page":"NVTX.jl","title":"NVTX.jl","text":"","category":"section"},{"location":"","page":"NVTX.jl","title":"NVTX.jl","text":"NVTX.jl provides Julia bindings to the NVIDIA Tools Extension Library (NVTX) for instrumenting Julia code for use with the Nsight systems profiler.","category":"page"},{"location":"#Installation","page":"NVTX.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"NVTX.jl","title":"NVTX.jl","text":"NVTX.jl includes the necessary NVTX library for supported platforms, however you will need to install the NVIDIA Nsight Systems to actually run the profiler: it is available for Linux (x86_64, Aarch64, Power) and Windows (x86_64), and the profile viewer is available on Linux, Windows and MacOS.","category":"page"},{"location":"","page":"NVTX.jl","title":"NVTX.jl","text":"NVTX.jl can be loaded on any platform, even those without the NVTX library, and so can safely be included as a package dependency.","category":"page"},{"location":"#Instrumenting-Julia-code","page":"NVTX.jl","title":"Instrumenting Julia code","text":"","category":"section"},{"location":"","page":"NVTX.jl","title":"NVTX.jl","text":"The simplest way to use this package is through the macros NVTX.@mark, NVTX.@range, NVTX.@annotate.","category":"page"},{"location":"","page":"NVTX.jl","title":"NVTX.jl","text":"NVTX.@mark \"my message\"\n\nNVTX.@range \"my message\" begin\n    # code to measure\nend\n\nNVTX.@annotate function myfunction(args...)\n    # function body\nend","category":"page"},{"location":"#Instrumenting-Julia-internals","page":"NVTX.jl","title":"Instrumenting Julia internals","text":"","category":"section"},{"location":"","page":"NVTX.jl","title":"NVTX.jl","text":"Additionally, it is possible to annotate the Julia garbage collector and inference by calling NVTX.enable_gc_hooks() and NVTX.enable_inference_hook(), or setting the JULIA_NVTX_CALLBACKS environment variable to a comma (,) or bar (|) separated list of:","category":"page"},{"location":"","page":"NVTX.jl","title":"NVTX.jl","text":"gc: instrument the Julia garbage collector\nalloc: instrument calls to alloc\nfree: instrument calls to free\ninference: instrument calls to compiler inference.","category":"page"},{"location":"#Running-the-profiler","page":"NVTX.jl","title":"Running the profiler","text":"","category":"section"},{"location":"","page":"NVTX.jl","title":"NVTX.jl","text":"To run the Nsight Systems profiler on a script, use","category":"page"},{"location":"","page":"NVTX.jl","title":"NVTX.jl","text":"nsys profile julia script.jl","category":"page"},{"location":"","page":"NVTX.jl","title":"NVTX.jl","text":"See Nsight Systems User Manual for more information.","category":"page"},{"location":"tips/#Nsight-Systems-tips","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"","category":"section"},{"location":"tips/#MPI","page":"Nsight Systems tips","title":"MPI","text":"","category":"section"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"Nsight Systems can profile MPI operations, and can be used in two ways:","category":"page"},{"location":"tips/#Profiler-outside-launcher","page":"Nsight Systems tips","title":"Profiler outside launcher","text":"","category":"section"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"nsys profile <launcher> <program>","category":"page"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"In this approach, nsys profile calls the MPI launcher (e.g. mpiexec), which in turn calls the scipt:","category":"page"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"nsys profile --trace=nvtx,mpi --mpi-impl=openmpi mpiexec -n 2 julia --project mpi.jl","category":"page"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"This will generate one report for the whole run, but only works when all MPI processes are on the one machine.","category":"page"},{"location":"tips/#Launcher-outside-profiler","page":"Nsight Systems tips","title":"Launcher outside profiler","text":"","category":"section"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"<launcher> nsys profile <program>","category":"page"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"Alternativelym the launcher can be used to start multiple copies of the profiler, which will generate a report for each MPI process. You will need to specify a unique name for each file, which can be done by --output= with using %q to interpolate an environment variable. Most launchers will set the MPI_COMM_WORLD rank of each process as an environment variable (e.g. PMI_RANK or OMPI_COMM_WORLD_RANK).","category":"page"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"mpiexec -n 2 nsys profile --trace=nvtx,mpi --mpi-impl=openmpi --output=report.%q{OMPI_COMM_WORLD_RANK} julia --project mpi.jl","category":"page"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"This file can be opened as a \"multi-report view\".","category":"page"},{"location":"tips/#Reducing-overhead","page":"Nsight Systems tips","title":"Reducing overhead","text":"","category":"section"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"The profiler itself has some overhead. Typically it will make use of another thread, but if there insufficient hardware resources available, it may result in occasionaly pauses in the program being profiled. ","category":"page"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"When using a HPC cluster scheduler such as Slurm, this can be reduced by allocating an additional CPU core per MPI process for the profiler (e.g. via the --cpus-per-task option in Slurm). To ensure that these are scheduled correctly, it is best to \"bind\" the CPU cores per task. If launching using srun, then use the --cpu-bind=cores; if launching using Open MPI mpiexec, use --map-by node:PE=$cpus_per_task --bind-to core.","category":"page"},{"location":"tips/#Querying-profiles","page":"Nsight Systems tips","title":"Querying profiles","text":"","category":"section"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"If you need to query the profile data programatically, the easiest option is to first convert to make use of the Sqlite format, either by the --export argument, or using the nsys export command.","category":"page"},{"location":"tips/","page":"Nsight Systems tips","title":"Nsight Systems tips","text":"The format of the resulting file is documented in the SQLite Schema Reference.","category":"page"}]
}
